-- =================================================================
-- DEFINITIVE SCHEMA RESET FOR KOPISTOCK
-- This script will completely reset the application's database schema.
-- It drops all existing objects and rebuilds them from scratch
-- to ensure a clean, stable, and correct state.
-- =================================================================

-- =================================================================
-- SECTION 1: CLEANUP (DROP EXISTING OBJECTS)
-- Drop objects in reverse order of dependency to avoid errors.
-- =================================================================

-- Drop the trigger from the auth.users table first
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Drop all functions
DROP FUNCTION IF EXISTS public.handle_new_user();
DROP FUNCTION IF EXISTS public.get_item_stock(integer);
DROP FUNCTION IF EXISTS public.get_item_stock_at_location(integer, integer);
DROP FUNCTION IF EXISTS public.snapshot_stock_for_opname(integer, integer[]);
DROP FUNCTION IF EXISTS public.approve_opname_session(integer);
DROP FUNCTION IF EXISTS public.get_dashboard_metrics();
DROP FUNCTION IF EXISTS public.get_opname_summary_chart_data();
DROP FUNCTION IF EXISTS public.get_stock_summary_report();
DROP FUNCTION IF EXISTS public.get_opname_history_report();
DROP FUNCTION IF EXISTS public.get_low_stock_items();

-- Drop all tables (using CASCADE to handle dependencies like policies)
DROP TABLE IF EXISTS public.stock_opname_items CASCADE;
DROP TABLE IF EXISTS public.stock_opname_sessions CASCADE;
DROP TABLE IF EXISTS public.stock_movements CASCADE;
DROP TABLE IF EXISTS public.items CASCADE;
DROP TABLE IF EXISTS public.suppliers CASCADE;
DROP TABLE IF EXISTS public.locations CASCADE;
DROP TABLE IF EXISTS public.item_categories CASCADE;
DROP TABLE IF EXISTS public.users CASCADE;


-- =================================================================
-- SECTION 2: TABLE CREATION
-- Recreate all tables with the correct structure.
-- =================================================================

-- users table
CREATE TABLE public.users (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name text,
    email text UNIQUE,
    role text DEFAULT 'staff',
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);

-- item_categories table
CREATE TABLE public.item_categories (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    description text,
    created_at timestamp with time zone DEFAULT now()
);

-- locations table
CREATE TABLE public.locations (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    type text DEFAULT 'warehouse',
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now()
);

-- suppliers table
CREATE TABLE public.suppliers (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    contact_person text,
    phone text,
    email text,
    notes text,
    created_at timestamp with time zone DEFAULT now()
);

-- items table
CREATE TABLE public.items (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    sku text UNIQUE,
    category_id bigint REFERENCES public.item_categories(id),
    unit text NOT NULL,
    purchase_unit text,
    conversion_to_base numeric,
    cost_price numeric NOT NULL DEFAULT 0,
    min_stock numeric NOT NULL DEFAULT 0,
    default_location_id bigint REFERENCES public.locations(id),
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);

-- stock_movements table
CREATE TABLE public.stock_movements (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    item_id bigint NOT NULL REFERENCES public.items(id),
    location_id bigint NOT NULL REFERENCES public.locations(id),
    quantity_change numeric NOT NULL,
    movement_type text NOT NULL,
    reference_id text,
    note text,
    created_by uuid REFERENCES public.users(id),
    created_at timestamp with time zone DEFAULT now()
);

-- stock_opname_sessions table
CREATE TABLE public.stock_opname_sessions (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    status text NOT NULL DEFAULT 'pending',
    created_by uuid REFERENCES public.users(id) DEFAULT auth.uid(),
    created_at timestamp with time zone DEFAULT now()
);

-- stock_opname_items table
CREATE TABLE public.stock_opname_items (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    session_id bigint NOT NULL REFERENCES public.stock_opname_sessions(id) ON DELETE CASCADE,
    item_id bigint NOT NULL REFERENCES public.items(id),
    location_id bigint NOT NULL REFERENCES public.locations(id),
    system_stock_at_start numeric NOT NULL,
    physical_count numeric,
    notes text,
    created_at timestamp with time zone DEFAULT now()
);


-- =================================================================
-- SECTION 3: FUNCTIONS AND TRIGGERS
-- Recreate all functions and triggers with security best practices.
-- =================================================================

-- Function to create a user profile
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.users (id, full_name, email, role)
  VALUES (new.id, new.raw_user_meta_data->>'full_name', new.email, new.raw_user_meta_data->>'role');
  RETURN new;
END;
$$;

-- Trigger to call the function on new user signup
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Function to get total stock for an item across all locations
CREATE OR REPLACE FUNCTION public.get_item_stock(p_item_id bigint)
RETURNS numeric
LANGUAGE sql
STABLE
SET search_path = public
AS $$
  SELECT COALESCE(sum(quantity_change), 0)
  FROM stock_movements
  WHERE item_id = p_item_id;
$$;

-- Function to get stock for an item at a specific location
CREATE OR REPLACE FUNCTION public.get_item_stock_at_location(p_item_id bigint, p_location_id bigint)
RETURNS numeric
LANGUAGE sql
STABLE
SET search_path = public
AS $$
  SELECT COALESCE(sum(quantity_change), 0)
  FROM stock_movements
  WHERE item_id = p_item_id AND location_id = p_location_id;
$$;

-- Function to create a snapshot of stock for an opname session
CREATE OR REPLACE FUNCTION public.snapshot_stock_for_opname(opname_session_id bigint, location_ids integer[])
RETURNS void
LANGUAGE plpgsql
SET search_path = public
AS $$
BEGIN
  INSERT INTO stock_opname_items (session_id, item_id, location_id, system_stock_at_start)
  SELECT
    opname_session_id,
    i.id,
    l.id,
    get_item_stock_at_location(i.id, l.id)
  FROM items i
  CROSS JOIN locations l
  WHERE i.is_active = true AND l.is_active = true AND l.id = ANY(location_ids);
END;
$$;

-- Function to approve an opname session and adjust stock
CREATE OR REPLACE FUNCTION public.approve_opname_session(p_session_id bigint)
RETURNS void
LANGUAGE plpgsql
SET search_path = public
AS $$
DECLARE
  opname_item record;
  variance numeric;
BEGIN
  -- Update session status
  UPDATE stock_opname_sessions SET status = 'approved' WHERE id = p_session_id;

  -- Loop through opname items and create adjustments
  FOR opname_item IN
    SELECT * FROM stock_opname_items WHERE session_id = p_session_id AND physical_count IS NOT NULL
  LOOP
    variance := opname_item.physical_count - opname_item.system_stock_at_start;
    IF variance != 0 THEN
      INSERT INTO stock_movements (item_id, location_id, quantity_change, movement_type, reference_id, created_by)
      VALUES (
        opname_item.item_id,
        opname_item.location_id,
        variance,
        'opname_adjustment',
        'opname_session_' || p_session_id,
        auth.uid()
      );
    END IF;
  END LOOP;
END;
$$;

-- Reporting Functions
CREATE OR REPLACE FUNCTION public.get_dashboard_metrics()
RETURNS TABLE(total_items bigint, total_stock_value numeric, active_locations bigint, low_stock_items_count bigint)
LANGUAGE sql
STABLE
SET search_path = public
AS $$
  SELECT
    (SELECT COUNT(*) FROM items WHERE is_active = true) as total_items,
    (SELECT SUM(get_item_stock(i.id) * i.cost_price) FROM items i) as total_stock_value,
    (SELECT COUNT(*) FROM locations WHERE is_active = true) as active_locations,
    (SELECT COUNT(*) FROM (SELECT 1 FROM items i WHERE get_item_stock(i.id) < i.min_stock AND i.is_active = true) as low_stock) as low_stock_items_count;
$$;

CREATE OR REPLACE FUNCTION public.get_opname_summary_chart_data()
RETURNS TABLE(created_at timestamptz, total_variance_value numeric)
LANGUAGE sql
STABLE
SET search_path = public
AS $$
  SELECT
    s.created_at,
    SUM(COALESCE(i.physical_count, i.system_stock_at_start) - i.system_stock_at_start * it.cost_price) as total_variance_value
  FROM stock_opname_sessions s
  JOIN stock_opname_items i ON s.id = i.session_id
  JOIN items it ON i.item_id = it.id
  WHERE s.status = 'approved'
  GROUP BY s.id, s.created_at
  ORDER BY s.created_at DESC
  LIMIT 5;
$$;

CREATE OR REPLACE FUNCTION public.get_stock_summary_report()
RETURNS TABLE(item_name text, location_name text, quantity numeric, stock_value numeric)
LANGUAGE sql
STABLE
SET search_path = public
AS $$
  SELECT
    i.name as item_name,
    l.name as location_name,
    sm.total_quantity as quantity,
    (sm.total_quantity * i.cost_price) as stock_value
  FROM (
    SELECT item_id, location_id, sum(quantity_change) as total_quantity
    FROM stock_movements
    GROUP BY item_id, location_id
  ) sm
  JOIN items i ON sm.item_id = i.id
  JOIN locations l ON sm.location_id = l.id
  WHERE sm.total_quantity != 0
  ORDER BY i.name, l.name;
$$;

CREATE OR REPLACE FUNCTION public.get_opname_history_report()
RETURNS TABLE(session_id bigint, created_at timestamptz, status text, total_variance numeric, total_variance_value numeric)
LANGUAGE sql
STABLE
SET search_path = public
AS $$
  SELECT
    s.id as session_id,
    s.created_at,
    s.status,
    SUM(COALESCE(i.physical_count, i.system_stock_at_start) - i.system_stock_at_start) as total_variance,
    SUM((COALESCE(i.physical_count, i.system_stock_at_start) - i.system_stock_at_start) * it.cost_price) as total_variance_value
  FROM stock_opname_sessions s
  JOIN stock_opname_items i ON s.id = i.session_id
  JOIN items it ON i.item_id = it.id
  GROUP BY s.id, s.created_at, s.status
  ORDER BY s.created_at DESC;
$$;

CREATE OR REPLACE FUNCTION public.get_low_stock_items()
RETURNS TABLE(item_id bigint, item_name text, item_sku text, current_quantity numeric, min_stock_level numeric, unit text)
LANGUAGE sql
STABLE
SET search_path = public
AS $$
  SELECT
    i.id as item_id,
    i.name as item_name,
    i.sku as item_sku,
    get_item_stock(i.id) as current_quantity,
    i.min_stock as min_stock_level,
    i.unit
  FROM items i
  WHERE get_item_stock(i.id) < i.min_stock AND i.is_active = true
  ORDER BY i.name;
$$;


-- =================================================================
-- SECTION 4: ROW LEVEL SECURITY (RLS)
-- Re-enable RLS and create all policies with the correct syntax.
-- =================================================================

-- Enable RLS for all tables
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.item_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.locations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.suppliers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.stock_movements ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.stock_opname_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.stock_opname_items ENABLE ROW LEVEL SECURITY;

-- Policies for users
CREATE POLICY "Allow users to see their own profile" ON public.users FOR SELECT TO authenticated USING (id = auth.uid());
CREATE POLICY "Allow users to update their own profile" ON public.users FOR UPDATE TO authenticated USING (id = auth.uid()) WITH CHECK (id = auth.uid());

-- Policies for master data (categories, locations, suppliers, items)
CREATE POLICY "Allow all authenticated read" ON public.item_categories FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow admin write" ON public.item_categories FOR ALL TO authenticated USING ((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager')) WITH CHECK ((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager'));

CREATE POLICY "Allow all authenticated read" ON public.locations FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow admin write" ON public.locations FOR ALL TO authenticated USING ((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager')) WITH CHECK ((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager'));

CREATE POLICY "Allow all authenticated read" ON public.suppliers FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow admin write" ON public.suppliers FOR ALL TO authenticated USING ((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager')) WITH CHECK ((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager'));

CREATE POLICY "Allow all authenticated read" ON public.items FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow admin write" ON public.items FOR ALL TO authenticated USING ((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager')) WITH CHECK ((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager'));

-- Policies for stock_movements
CREATE POLICY "Allow authenticated read" ON public.stock_movements FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow authenticated insert" ON public.stock_movements FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "Allow admin update" ON public.stock_movements FOR UPDATE TO authenticated USING ((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager'));
CREATE POLICY "Allow admin delete" ON public.stock_movements FOR DELETE TO authenticated USING ((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager'));

-- Policies for opname sessions
CREATE POLICY "Allow authenticated read" ON public.stock_opname_sessions FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow admin write" ON public.stock_opname_sessions FOR ALL TO authenticated USING ((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager')) WITH CHECK ((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager'));

-- Policies for opname items
CREATE POLICY "Allow authenticated read" ON public.stock_opname_items FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow authenticated write" ON public.stock_opname_items FOR ALL TO authenticated WITH CHECK (true);
