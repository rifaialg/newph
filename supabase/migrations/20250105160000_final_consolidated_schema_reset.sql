-- =================================================================
-- FINAL CONSOLIDATED SCHEMA RESET
-- This script will completely reset and rebuild the application's public schema.
-- It is designed to be run once to fix all previous migration errors.
-- WARNING: This will delete all existing data in the tables it manages.
-- =================================================================

-- ========= TEARDOWN PHASE =========
-- Drop dependent objects first in the correct reverse order.

-- 1. Drop the trigger from auth.users
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- 2. Drop functions
DROP FUNCTION IF EXISTS public.handle_new_user();
DROP FUNCTION IF EXISTS public.get_item_stock(bigint);
DROP FUNCTION IF EXISTS public.get_item_stock_at_location(bigint, bigint);

-- 3. Drop tables using CASCADE to handle all dependencies like foreign keys and policies.
DROP TABLE IF EXISTS public.stock_opname_items CASCADE;
DROP TABLE IF EXISTS public.stock_opname_sessions CASCADE;
DROP TABLE IF EXISTS public.stock_movements CASCADE;
DROP TABLE IF EXISTS public.items CASCADE;
DROP TABLE IF EXISTS public.suppliers CASCADE;
DROP TABLE IF EXISTS public.locations CASCADE;
DROP TABLE IF EXISTS public.item_categories CASCADE;
DROP TABLE IF EXISTS public.users CASCADE;


-- ========= BUILD PHASE =========
-- Recreate everything from a clean state in the correct order.

-- 1. Table: users
CREATE TABLE public.users (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name text,
    email text UNIQUE,
    role text DEFAULT 'staff'::text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

-- 2. Table: item_categories
CREATE TABLE public.item_categories (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    description text
);

-- 3. Table: locations
CREATE TABLE public.locations (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    type text DEFAULT 'warehouse'::text,
    is_active boolean DEFAULT true NOT NULL
);

-- 4. Table: suppliers
CREATE TABLE public.suppliers (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    contact_person text,
    phone text,
    email text,
    notes text
);

-- 5. Table: items
CREATE TABLE public.items (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    sku text UNIQUE,
    category_id bigint REFERENCES public.item_categories(id),
    unit text NOT NULL,
    purchase_unit text,
    conversion_to_base numeric DEFAULT 1,
    cost_price numeric DEFAULT 0 NOT NULL,
    min_stock numeric DEFAULT 0 NOT NULL,
    default_location_id bigint REFERENCES public.locations(id),
    is_active boolean DEFAULT true NOT NULL
);

-- 6. Table: stock_movements
CREATE TABLE public.stock_movements (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    item_id bigint NOT NULL REFERENCES public.items(id),
    location_id bigint NOT NULL REFERENCES public.locations(id),
    quantity_change numeric NOT NULL,
    movement_type text NOT NULL,
    reference_id text,
    note text,
    created_by uuid REFERENCES public.users(id),
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

-- 7. Table: stock_opname_sessions
CREATE TABLE public.stock_opname_sessions (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by uuid REFERENCES public.users(id),
    status text DEFAULT 'pending'::text NOT NULL,
    notes text
);

-- 8. Table: stock_opname_items
CREATE TABLE public.stock_opname_items (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    session_id bigint NOT NULL REFERENCES public.stock_opname_sessions(id) ON DELETE CASCADE,
    item_id bigint NOT NULL REFERENCES public.items(id),
    location_id bigint NOT NULL REFERENCES public.locations(id),
    system_stock_at_start numeric NOT NULL,
    physical_count numeric,
    notes text,
    UNIQUE (session_id, item_id, location_id)
);


-- ========= FUNCTIONS AND TRIGGERS =========

-- 1. Function: handle_new_user
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.users (id, full_name, email, role)
  VALUES (
    new.id,
    new.raw_user_meta_data->>'full_name',
    new.email,
    new.raw_user_meta_data->>'role'
  );
  RETURN new;
END;
$$;

-- 2. Trigger: on_auth_user_created
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION public.handle_new_user();

-- 3. Function: get_item_stock
CREATE OR REPLACE FUNCTION public.get_item_stock(p_item_id bigint)
RETURNS numeric
LANGUAGE sql STABLE
SET search_path = public
AS $$
    SELECT COALESCE(SUM(quantity_change), 0)
    FROM stock_movements
    WHERE item_id = p_item_id;
$$;

-- 4. Function: get_item_stock_at_location
CREATE OR REPLACE FUNCTION public.get_item_stock_at_location(p_item_id bigint, p_location_id bigint)
RETURNS numeric
LANGUAGE sql STABLE
SET search_path = public
AS $$
    SELECT COALESCE(SUM(quantity_change), 0)
    FROM stock_movements
    WHERE item_id = p_item_id AND location_id = p_location_id;
$$;


-- ========= ROW LEVEL SECURITY (RLS) =========

-- Enable RLS and define policies for each table

ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own data" ON public.users FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Allow users to update their own data" ON public.users FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);

ALTER TABLE public.item_categories ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated read access" ON public.item_categories FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow admin/manager write access" ON public.item_categories FOR ALL TO authenticated USING (((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager'))) WITH CHECK (((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager')));

ALTER TABLE public.locations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated read access" ON public.locations FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow admin/manager write access" ON public.locations FOR ALL TO authenticated USING (((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager'))) WITH CHECK (((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager')));

ALTER TABLE public.suppliers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated read access" ON public.suppliers FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow admin/manager write access" ON public.suppliers FOR ALL TO authenticated USING (((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager'))) WITH CHECK (((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager')));

ALTER TABLE public.items ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated read access" ON public.items FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow admin/manager write access" ON public.items FOR ALL TO authenticated USING (((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager'))) WITH CHECK (((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager')));

ALTER TABLE public.stock_movements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated read access" ON public.stock_movements FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow authenticated write access" ON public.stock_movements FOR INSERT TO authenticated WITH CHECK (true);

ALTER TABLE public.stock_opname_sessions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to manage their own sessions" ON public.stock_opname_sessions FOR ALL TO authenticated USING ((auth.uid() = created_by)) WITH CHECK ((auth.uid() = created_by));
CREATE POLICY "Allow admin/manager to view all sessions" ON public.stock_opname_sessions FOR SELECT TO authenticated USING (((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager')));

ALTER TABLE public.stock_opname_items ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to access items in their sessions" ON public.stock_opname_items FOR ALL TO authenticated USING ((EXISTS (SELECT 1 FROM public.stock_opname_sessions s WHERE s.id = session_id AND s.created_by = auth.uid())));
CREATE POLICY "Allow admin/manager to view all opname items" ON public.stock_opname_items FOR SELECT TO authenticated USING (((SELECT role FROM public.users WHERE id = auth.uid()) IN ('owner', 'manager')));
